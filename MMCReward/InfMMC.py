# This file was *autogenerated* from the file InfMMC.sage.
from sage.all_cmdline import *   # import sage library
_sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_5 = Integer(5); _sage_const_4 = Integer(4); _sage_const_100 = Integer(100); _sage_const_1p0 = RealNumber('1.0'); _sage_const_10 = Integer(10); _sage_const_0p5 = RealNumber('0.5'); _sage_const_0p01 = RealNumber('0.01')
action = {}
class Queue: #A class for the queueing system
    def __init__(self,lmbda,mu,C,R,Thresh = False,alpha = _sage_const_1 ,epsilon = _sage_const_10 **-_sage_const_2 ):
        self.lmbda = lmbda
        self.mu = mu
        self.R = R
        self.servers = C

        self.Selfish =  int(R*self.mu)
        self.alpha = alpha
        self.epsilon = epsilon
        self.A = {}
        if Thresh == False:
            for N in range(_sage_const_100 ):
                self.A[N] = [_sage_const_0 ,_sage_const_1 ]
        else:
            for N in range(Thresh):
                self.A[N] = [_sage_const_1 ]
            for N in range(Thresh,_sage_const_10 *Thresh):
                self.A[N] = [_sage_const_0 ]

        self.findQ()
        self.findP()

    def findQ(self): #Transition rate matrix for the queue
        Q = MatrixSpace(QQ,_sage_const_5 *self.servers,_sage_const_5 *self.servers)
        rowdata = []

        for e in range(_sage_const_5 *self.servers):

            for i in range(_sage_const_5 *self.servers):
                if i == e+_sage_const_1 :
                    rowdata.append(self.lmbda)
                elif i == e-_sage_const_1 :
                        if e<= self.servers:
                            rowdata.append(e*self.mu)
                        else:
                            rowdata.append(self.servers*self.mu)
                else:
                    rowdata.append(_sage_const_0 )

        self.Q = Q(rowdata)
        rowsums = [sum(e) for e in self.Q]
        for i in range(_sage_const_5 *self.servers):
            self.Q[i,i] = -rowsums[i]

    def findP(self): #Converts Q to P
        Diag = []

        for e in range(_sage_const_5 *self.servers):

            Diag.append(abs(self.Q[e][e]))

        t = _sage_const_1 /max(Diag)
        self.P = self.Q*t + identity_matrix(self.Q.nrows())
        self.P2 = [self.P[_sage_const_0 ][_sage_const_0 ],self.P[_sage_const_0 ][_sage_const_1 ]]

    def Pij(self,i,j = _sage_const_0 ):

        return self.P[i][j]


    def Cost(self,state,action): # Returns the cost
        if action == _sage_const_0 :
            return _sage_const_0 
        else:
            if state < self.servers:
                #return 1*((self.mu)**-1) - self.R
                return (_sage_const_1 )/((self.mu)) - self.R
            else:
                return (state+_sage_const_1 )/((self.mu*self.servers)) - self.R

    def SolveNHor(self,T=_sage_const_0 ,N=_sage_const_0 ,service = False): #Recursively calculates cost for current state

        values = {}
        values[N] = []
        if not self.alpha**T < self.epsilon:

            if N >= self.servers or N == _sage_const_0 :

                if not service:

                    for e in self.A[N]:
                        values[N].append((( (self.alpha**T)*(self.Cost(N,e))+self.P2[_sage_const_0 ]*self.SolveNHor(T+_sage_const_1 ,max(N+e-_sage_const_1 ,_sage_const_0 ),True))+self.P2[_sage_const_1 ]*self.SolveNHor(T+_sage_const_1 ,N+e)))

                else:
                    values[N].append((self.P2[_sage_const_0 ]*self.SolveNHor(T+_sage_const_1 ,max(N-_sage_const_1 ,_sage_const_0 ),True))+self.P2[_sage_const_1 ]*self.SolveNHor(T+_sage_const_1 ,N))

            else:
                if not service:

                    for e in self.A[N]:
                        values[N].append((( (self.alpha**T)*(self.Cost(N,e)) + self.Pij(N+e,N+e-_sage_const_1 )*self.SolveNHor(T+_sage_const_1 ,N+e-_sage_const_1 ,True)) + self.Pij(N + e,N + e)*self.SolveNHor(T + _sage_const_1 , N + e,True )  + self.P2[_sage_const_1 ]*self.SolveNHor(T + _sage_const_1 ,N+e)))

                else:
                    values[N].append( self.Pij(N,N-_sage_const_1 )*self.SolveNHor(T+_sage_const_1 ,N-_sage_const_1 ,True) + self.Pij(N,N)*self.SolveNHor(T+_sage_const_1 ,N,True) + self.P2[_sage_const_1 ]*self.SolveNHor(T+_sage_const_1 ,N) )

            action[N] = values[N].index(min(values[N]))

            return min(values[N])

        else:
            if not service:
                for e in self.A[N]:
                    values[N].append( ( self.alpha**T ) * ( self.Cost(N,e) ) )
            else:
                for e in self.A[N]:
                    values[N].append(_sage_const_0 )
            return min(values[N])
simple = Queue(_sage_const_4 ,_sage_const_5 ,_sage_const_2 ,_sage_const_1p0 ,Thresh = _sage_const_2 ,alpha = _sage_const_0p5 ,epsilon = _sage_const_0p01 )
print simple.SolveNHor(_sage_const_0 ,_sage_const_0 )
