# This file was *autogenerated* from the file ParalellGame.sage.
from sage.all_cmdline import *   # import sage library
import time
import multiprocessing as mp
action = {}
class Queue: #A class for the queueing system
    def __init__(self,lmbda,mu,C,R,Thresh = False,alpha = Integer(1),epsilon = Integer(10)**-Integer(2),end_T = Integer(0)):
        self.lmbda = lmbda
        self.mu = mu
        self.R = R
        self.servers = C
        self.action = {}
        self.ParaT = False
        self.end_T = end_T
        self.Selfish =  int(R*self.mu)
        self.alpha = alpha
        self.epsilon = epsilon
        self.A = {}
        self.cpus = mp.cpu_count()
        self.BaseDict = {}
        if Thresh == False:
            for N in range(Integer(100)):
                self.A[N] = [Integer(0),Integer(1)]
        else:
            for N in range(Thresh):
                self.A[N] = [Integer(1)]
            for N in range(Thresh,Integer(10)*Thresh):
                self.A[N] = [Integer(0)]

        self.findQ()
        self.findP()

    def find_nodes(self,nodes = [[Integer(0),Integer(0)]],MaxT=Integer(0)):
        T = Integer(0)
        Tdict = {}
        while len(nodes) <= self.cpus:
            new_nodes = []
            for i in nodes:
                for e in self.Branch(i):
                    if e not in new_nodes:
                        new_nodes.append(e)

            if len(new_nodes)> self.cpus :
                break
            else:
                T += Integer(1)
                nodes = new_nodes

        nodes = [(T, r[Integer(0)], r[Integer(1)]) for r in nodes]
        self.ParaT = T
        return nodes

    def Branch(self,state):
        if state >= self.servers or state == Integer(0) :
            if state[Integer(1)] == True:
                return [[max(state[Integer(0)] - Integer(1),Integer(0)), True],[state[Integer(0)],False]]

            else:
                return [[max(state[Integer(0)] - Integer(1),Integer(0)), True],[state[Integer(0)],False],[state[Integer(0)] + Integer(1),False],[state[Integer(0)],True]]

        else:
            if state[Integer(1)] == True:
                return [[max(state[Integer(0)] - Integer(1),Integer(0)), True],[state[Integer(0)],True],[state[Integer(0)],False]]

            else:
                return [[max(state[Integer(0)] - Integer(1),Integer(0)), True],[state[Integer(0)] + Integer(1),True],[state[Integer(0)],False],[state[Integer(0)] + Integer(1),False],[state[Integer(0)],True]]

    def Submit(self,T = Integer(6)):
        self.BaseDict = {}
        jobs = self.find_nodes()
        B = self.SolveNHor(jobs)
        for r in B:
            self.BaseDict['%s%s' %(r[Integer(0)][Integer(0)][Integer(1)],r[Integer(0)][Integer(0)][Integer(2)])] = r[Integer(1)]


    def findQ(self): #Transition rate matrix for the queue
        Q = MatrixSpace(QQ,Integer(5)*self.servers,Integer(5)*self.servers)
        rowdata = []

        for e in range(Integer(5)*self.servers):

            for i in range(Integer(5)*self.servers):
                if i == e+Integer(1):
                    rowdata.append(self.lmbda)
                elif i == e-Integer(1):
                        if e<= self.servers:
                            rowdata.append(e*self.mu)
                        else:
                            rowdata.append(self.servers*self.mu)
                else:
                    rowdata.append(Integer(0))

        self.Q = Q(rowdata)
        rowsums = [sum(e) for e in self.Q]
        for i in range(Integer(5)*self.servers):
            self.Q[i,i] = -rowsums[i]

    def findP(self): #Converts Q to P
        Diag = []

        for e in range(Integer(5)*self.servers):

            Diag.append(abs(self.Q[e][e]))

        t = Integer(1)/max(Diag)
        self.P = self.Q*t + identity_matrix(self.Q.nrows())
        self.P2 = [self.P[Integer(0)][Integer(0)],self.P[Integer(0)][Integer(1)]]
    def Pij(self,i,j = Integer(0)):

        return self.P[i][j]


    def Cost(self,state,action): # Returns the cost
        if action == Integer(0):
            return Integer(0)
        else:
            if state < self.servers:
                return Integer(1)*((self.mu)**-Integer(1))
            else:
                return (state+Integer(1))/((self.mu*self.servers))
    @parallel
    def SolveNHor(self,T=Integer(0),N=Integer(0),service = False): #Recursively calculates cost for current state

        values = {}
        values[N] = []

        if T == self.ParaT and '%s%s' %(N,service) in self.BaseDict:
            return self.BaseDict[ '%s%s' %(N,service)]

        if not self.alpha**T < self.epsilon:
        #if not T == self.end_T:

            if N >= self.servers or N == Integer(0):

                if not service:

                    for e in self.A[N]:
                        values[N].append((( (self.alpha**T)*(self.Cost(N,e)) + (Integer(1)-e)*self.R + self.P2[Integer(0)]*self.SolveNHor(T+Integer(1),max(N+e-Integer(1),Integer(0)),True))+self.P2[Integer(1)]*self.SolveNHor(T+Integer(1),N+e)))
                    if N in action:

                        action[N][T] = values[N].index(min(values[N]))
                    else:

                        action[N] = {T:values[N].index(min(values[N]))}

                else:
                    values[N].append((self.P2[Integer(0)]*self.SolveNHor(T+Integer(1),max(N-Integer(1),Integer(0)),True))+self.P2[Integer(1)]*self.SolveNHor(T+Integer(1),N))

            else:
                if not service:

                    for e in self.A[N]:
                        values[N].append((( (self.alpha**T)*(self.Cost(N,e)) + (Integer(1)-e)*self.R + self.Pij(N+e,N+e-Integer(1))*self.SolveNHor(T+Integer(1),N+e-Integer(1),True)) + self.Pij(N + e,N + e)*self.SolveNHor(T + Integer(1), N + e,True )  + self.P2[Integer(1)]*self.SolveNHor(T + Integer(1),N+e)))
                    if N in action:

                        action[N][T] = values[N].index(min(values[N]))
                    else:

                        action[N] = {T:values[N].index(min(values[N]))}

                else:
                    values[N].append( self.Pij(N,N-Integer(1))*self.SolveNHor(T+Integer(1),N-Integer(1),True) + self.Pij(N,N)*self.SolveNHor(T+Integer(1),N,True) + self.P2[Integer(1)]*self.SolveNHor(T+Integer(1),N) )





            if T == Integer(0):

                policy = Integer(0)
                found = False
                for e in action:
                    if action[e] == Integer(0) and e >policy:
                        policy = e
                        found = True
                if found == False:
                    policy = len(action)
                return min(values[N]),policy
            else:
                return min(values[N])

        else:
            if not service:
                for e in self.A[N]:
                    values[N].append( ( self.alpha**T ) * ( self.Cost(N,e) - e*self.R) )
            else:
                for e in self.A[N]:
                    values[N].append(Integer(0))
            return min(values[N])
'''
Simple = Queue(4,5,2,0.01,alpha = 0.6,epsilon = 0.01)

A = Simple.SolveNHor(0,0)


M = MatrixSpace(QQ,len(action),len(action[0]))
Mdata= []

for e in action:
    for i in action[0]:
        if i in action[e]:
            Mdata.append(action[e][i])
        else:
            Mdata.append(0)
Mplot = M(Mdata)
Policy = Mplot.plot()

Policy.save('Policy.png')
'''
