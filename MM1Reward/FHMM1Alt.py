# This file was *autogenerated* from the file FHMM1Alt.sage.
from sage.all_cmdline import *   # import sage library
_sage_const_3 = Integer(3); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_1p0 = RealNumber('1.0'); _sage_const_10 = Integer(10)
import multiprocessing
action = {}

class Queue: #A class for the queueing system
    def __init__(self,lmbda,mu,R,TimeCost = _sage_const_1 ,K = False,alpha = _sage_const_1 ,epsilon = _sage_const_10 **-_sage_const_2 ):
        self.lmbda = lmbda
        self.mu = mu
        self.R = R
        self.TC = TimeCost
        self.queuelength = _sage_const_0 
        self.Selfish =  int(R*self.mu)
        self.alpha = alpha
        self.epsilon = epsilon
        self.A = [_sage_const_0 ,_sage_const_1 ]

        self.cpus = _sage_const_2 *multiprocessing.cpu_count()
        print multiprocessing.cpu_count()

        if K == False:
            self.K = self.Selfish
        else:
            self.K = K
        print self.K
        self.findQ()
        self.findP()

    def find_nodes(self,nodes = [[_sage_const_0 ,_sage_const_0 ]]):
        T = _sage_const_0 
        while len(nodes) < self.cpus-_sage_const_1 :
            new_nodes = []
            for i in nodes:
                for e in self.Branch(i):
                    new_nodes.append(e)

            nodes = new_nodes

        print nodes

    def Branch(self,state):

        if state[_sage_const_1 ] == True:
            return [[max(state[_sage_const_0 ] - _sage_const_1 ,_sage_const_0 ), True],[state[_sage_const_0 ],False]]

        else:
            return [[max(state[_sage_const_0 ] - _sage_const_1 ,_sage_const_0 ), True],[state[_sage_const_0 ],False],[state[_sage_const_0 ] + _sage_const_1 ,False],[state[_sage_const_0 ],True]]

    def findQ(self): #Transition rate matrix for the queue
        Q = MatrixSpace(QQ,self.K,self.K)
        rowdata = []

        for e in range(self.K):

            for i in range(self.K):
                if i == e+_sage_const_1 :
                    rowdata.append(self.lmbda)
                elif i == e-_sage_const_1 :
                        rowdata.append(self.mu)
                else:
                    rowdata.append(_sage_const_0 )

        self.Q = Q(rowdata)
        rowsums = [sum(e) for e in self.Q]
        for i in range(self.K):
            self.Q[i,i] = -rowsums[i]

    def findP(self): #Converts Q to P
        Diag = []

        for e in range(self.K):

            Diag.append(abs(self.Q[e][e]))

        t = _sage_const_1 /max(Diag)
        print t
        self.P = self.Q*t + identity_matrix(self.Q.nrows())
        self.P2 = [self.P[_sage_const_0 ][_sage_const_0 ],self.P[_sage_const_0 ][_sage_const_1 ]]
    def obtainpi(self):
        uniteigenvector = [e for e in self.P.eigenvectors_left() if e[_sage_const_0 ]==_sage_const_1 ][_sage_const_0 ][_sage_const_1 ][_sage_const_0 ]

        self.pi = uniteigenvector / sum(uniteigenvector)



    def Pij(self,i):

        return self.P2[i]


    def Cost(self,state,action): # Returns the cost
        if action == _sage_const_0 :
            return _sage_const_0 
        else:
            return (state+_sage_const_1 )*(self.mu)**-_sage_const_1  - self.R

    def SolveNHor(self,T=_sage_const_0 ,N=_sage_const_0 ,service = False): #Recursively calculates cost for current state

        values = {}
        values[N] = []
        if not T==_sage_const_0 :
            if not service:
                for e in self.A:
                    values[N].append(((self.Cost(N,e)+self.Pij(_sage_const_0 )*self.SolveNHor(T-_sage_const_1 ,max(N+e-_sage_const_1 ,_sage_const_0 ),True))+self.Pij(_sage_const_1 )*self.SolveNHor(T-_sage_const_1 ,N+e)))
            else:
                values[N].append((self.Pij(_sage_const_0 )*self.SolveNHor(T-_sage_const_1 ,max(N-_sage_const_1 ,_sage_const_0 ),True))+self.Pij(_sage_const_1 )*self.SolveNHor(T-_sage_const_1 ,N))

            action[N] = values[N].index(min(values[N]))
            return min(values[N])
        else:
            if not service:
                for e in self.A:
                    values[N].append((self.Cost(N,e)))
            else:
                for e in self.A:
                    values[N].append(_sage_const_0 )
            return min(values[N])



Simple = Queue(_sage_const_2 ,_sage_const_3 ,_sage_const_1p0 )
Simple.find_nodes([[_sage_const_0 ,_sage_const_0 ]])
'''
B = Simple.SolveNHor(T=8,N=0)
print Simple.P
print Simple.P2
print B
for e in action:
    print e,action[e]
'''
