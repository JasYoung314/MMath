# This file was *autogenerated* from the file Paralell.sage.
from sage.all_cmdline import *   # import sage library
import multiprocessing,time
action = {}

class Queue: #A class for the queueing system
    def __init__(self,lmbda,mu,R,TimeCost = Integer(1),K = False,alpha = Integer(1),epsilon = Integer(10)**-Integer(2)):

        self.lmbda = lmbda
        self.mu = mu
        self.R = R
        self.TC = TimeCost

        self.queuelength = Integer(0)
        self.Selfish =  int(R*self.mu)

        self.alpha = alpha
        self.epsilon = epsilon

        self.A = [Integer(0),Integer(1)]

        self.BaseDict = {}
        self.TDict = {}
        self.cpus = multiprocessing.cpu_count()
        print multiprocessing.cpu_count()
        self.ParaT = 'Nope'

        if K == False:
            self.K = self.Selfish
        else:
            self.K = K

        self.findQ()
        self.findP()

    def find_nodes(self,nodes = [[Integer(0),Integer(0)]],MaxT=Integer(0)):
        T = Integer(0)
        Tdict = {}
        while len(nodes) <= self.cpus:
            new_nodes = []
            for i in nodes:
                for e in self.Branch(i):
                    if e not in new_nodes:
                        new_nodes.append(e)

            if len(new_nodes)> self.cpus :
                break
            else:
                T += Integer(1)
                nodes = new_nodes

        nodes = [(MaxT -T, r[Integer(0)], r[Integer(1)]) for r in nodes]
        self.ParaT = MaxT - T
        return nodes

    def Branch(self,state):

        if state[Integer(1)] == True:
            return [[max(state[Integer(0)] - Integer(1),Integer(0)), True],[state[Integer(0)],False]]

        else:
            return [[max(state[Integer(0)] - Integer(1),Integer(0)), True],[state[Integer(0)],False],[state[Integer(0)] + Integer(1),False],[state[Integer(0)],True]]

    def Submit(self,T = Integer(6)):
        self.BaseDict = {}
        jobs = self.find_nodes(MaxT = T)
        print jobs
        B = self.SolveNHor(jobs)
        for r in B:
            self.BaseDict['%s%s' %(r[Integer(0)][Integer(0)][Integer(1)],r[Integer(0)][Integer(0)][Integer(2)])] = r[Integer(1)]
    def findQ(self): #Transition rate matrix for the queue
        Q = MatrixSpace(QQ,self.K,self.K)
        rowdata = []

        for e in range(self.K):

            for i in range(self.K):
                if i == e+Integer(1):
                    rowdata.append(self.lmbda)
                elif i == e-Integer(1):
                        rowdata.append(self.mu)
                else:
                    rowdata.append(Integer(0))

        self.Q = Q(rowdata)
        rowsums = [sum(e) for e in self.Q]
        for i in range(self.K):
            self.Q[i,i] = -rowsums[i]

    def findP(self): #Converts Q to P
        Diag = []

        for e in range(self.K):

            Diag.append(abs(self.Q[e][e]))

        t = Integer(1)/max(Diag)
        self.P = self.Q*t + identity_matrix(self.Q.nrows())
        self.P2 = [self.P[Integer(0)][Integer(0)],self.P[Integer(0)][Integer(1)]]
    def obtainpi(self):
        uniteigenvector = [e for e in self.P.eigenvectors_left() if e[Integer(0)]==Integer(1)][Integer(0)][Integer(1)][Integer(0)]

        self.pi = uniteigenvector / sum(uniteigenvector)



    def Pij(self,i):

        return self.P2[i]


    def Cost(self,state,action): # Returns the cost
        if action == Integer(0):
            return Integer(0)
        else:
            return (state+Integer(1))*(self.mu)**-Integer(1) - self.R

    @parallel
    def SolveNHor(self,T=Integer(0),N=Integer(0),service = False): #Recursively calculates cost for current state

        values = {}
        values[N] = []
        if T == self.ParaT and '%s%s' %(N,service) in self.BaseDict:
            print 'woof'
            return self.BaseDict[ '%s%s' %(N,service)]
        if not T==Integer(0):
            if not service:
                for e in self.A:
                    values[N].append(((self.Cost(N,e)+self.Pij(Integer(0))*self.SolveNHor(T-Integer(1),max(N+e-Integer(1),Integer(0)),True))+self.Pij(Integer(1))*self.SolveNHor(T-Integer(1),N+e)))
            else:
                values[N].append((self.Pij(Integer(0))*self.SolveNHor(T-Integer(1),max(N-Integer(1),Integer(0)),True))+self.Pij(Integer(1))*self.SolveNHor(T-Integer(1),N))

            action[N] = values[N].index(min(values[N]))
            return min(values[N])
        else:
            if not service:
                for e in self.A:
                    values[N].append((self.Cost(N,e)))
            else:
                for e in self.A:
                    values[N].append(Integer(0))
            return min(values[N])



Simple = Queue(Integer(2),Integer(3),RealNumber('1.0'))

Start1 = time.time()
A = Simple.SolveNHor(Integer(10),Integer(0))
Time1 = time.time() - Start1
print A
print 'Boring Serial ' , Time1

Start2 = time.time()
Simple.Submit(Integer(10))
B = Simple.SolveNHor(Integer(10),Integer(0))
Time2 = time.time()- Start2
print B
print 'New Paralell', Time2
