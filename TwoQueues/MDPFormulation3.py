# This file was *autogenerated* from the file MDPFormulation3.sage.
from sage.all_cmdline import *   # import sage library
_sage_const_3 = Integer(3); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_7 = Integer(7); _sage_const_5 = Integer(5); _sage_const_4 = Integer(4); _sage_const_40 = Integer(40); _sage_const_0p1 = RealNumber('0.1'); _sage_const_10 = Integer(10); _sage_const_20 = Integer(20)
class Queue: #A class for the queueing system
    #def __init__(self,lmbda,mu,C,beta,Policy = matrix([[0,0,2,2,2],[0,0,0,0,2],[1,1,1,2,2]])):
    def __init__(self,lmbda,mu,C,beta,Policy = _sage_const_7 ):
        self.lmbda = lmbda
        self.mu = mu
        self.beta = beta
        self.servers = C
        self.Policy = Policy

        self.StateValues = {}
        self.StateValues[_sage_const_0 ] = {}
        self.StateActions = {}
        self.StateActions[_sage_const_0 ] = {}
        self.states = []
        if self.Policy == _sage_const_7 :
            self.Selfish =  [_sage_const_10 ,_sage_const_10 ]
            print self.Selfish
        else:
            self.Selfish = [self.Policy.nrows() - _sage_const_1 ,self.Policy.ncols() - _sage_const_1 ]
        self.VIAStates = []
        self.NoStates = (self.Selfish[_sage_const_0 ] + _sage_const_1 )*(self.Selfish[_sage_const_1 ] + _sage_const_1 )

        self.TranProbs = {}
        self.Plmbda = lmbda/(lmbda + sum([C[e]*mu[e] for e in range(_sage_const_2 )]))

        for e in range((self.Selfish[_sage_const_0 ] + _sage_const_1 )):
            for k in range((self.Selfish[_sage_const_1 ] + _sage_const_1 ) ):
                self.states.append([e,k])
        for e in range((self.Selfish[_sage_const_0 ] +_sage_const_1  )):
            for k in range((self.Selfish[_sage_const_1 ] + _sage_const_1 ) ):
                for j in range(_sage_const_3 ):
                    self.VIAStates.append([e,k,j])
                    self.StateValues[_sage_const_0 ]['%s' %([e,k,j])] = _sage_const_0 

        self.A = [_sage_const_0 ,_sage_const_1 ,_sage_const_2 ]
        self.ADict = {}
        for e in self.states:
            if self.Policy == _sage_const_7 :
                if e[_sage_const_0 ] < self.Selfish[_sage_const_0 ] and e[_sage_const_1 ] < self.Selfish[_sage_const_1 ]:
                    self.ADict['%s' %e] = [_sage_const_0 ,_sage_const_1 ,_sage_const_2 ]
                elif e[_sage_const_0 ] == self.Selfish[_sage_const_0 ] and e[_sage_const_1 ] < self.Selfish[_sage_const_1 ]:
                    self.ADict['%s' %e] = [_sage_const_1 ,_sage_const_2 ]
                elif e[_sage_const_0 ] < self.Selfish[_sage_const_0 ] and e[_sage_const_1 ] == self.Selfish[_sage_const_1 ]:
                    self.ADict['%s' %e] = [_sage_const_0 ,_sage_const_2 ]
                elif e[_sage_const_0 ] == self.Selfish[_sage_const_0 ] and e[_sage_const_1 ] == self.Selfish[_sage_const_1 ]:
                    self.ADict['%s' %e] = [_sage_const_2 ]
            else:
                self.ADict['%s' %e] = [self.Policy[e[_sage_const_0 ],e[_sage_const_1 ]]]
        self.findQ()
        self.findP()

    def findQ(self): #Transition rate matrix for the queue
        Q = MatrixSpace(QQ,len(self.states),len(self.states))
        rowdata = []

        for e in self.states:

            for i in self.states:
                if i[_sage_const_0 ] == e[_sage_const_0 ] + _sage_const_1  and i[_sage_const_1 ] == e[_sage_const_1 ]:
                    rowdata.append(self.lmbda)


                elif i[_sage_const_0 ] == e[_sage_const_0 ]-_sage_const_1  and i[_sage_const_1 ] == e[_sage_const_1 ]+_sage_const_1 :
                    if e[_sage_const_0 ]<= self.servers[_sage_const_0 ]:
                        rowdata.append(e[_sage_const_0 ]*self.mu[_sage_const_0 ])
                    else:
                        rowdata.append(self.servers[_sage_const_0 ]*self.mu[_sage_const_0 ])

                elif i[_sage_const_0 ] == e[_sage_const_0 ] and i[_sage_const_1 ] == e[_sage_const_1 ] - _sage_const_1 :
                    if e[_sage_const_1 ]<= self.servers[_sage_const_1 ]:
                        rowdata.append(e[_sage_const_1 ]*self.mu[_sage_const_1 ] )
                    else:
                        rowdata.append(self.servers[_sage_const_1 ]*self.mu[_sage_const_1 ])

                else:
                    rowdata.append(_sage_const_0 )

        self.Q = Q(rowdata)
        rowsums = [sum(e) for e in self.Q]
        for i in range(self.NoStates):
            self.Q[i,i] = -rowsums[i]


    def findP(self): #Converts Q to P
        Diag = []

        for e in range(self.NoStates):

            Diag.append(abs(self.Q[e][e]))

        t = _sage_const_1 /max(Diag)
        self.P = self.Q*t + identity_matrix(self.Q.nrows())

        for e  in range(self.P.nrows()):
            self.TranProbs['%s' %self.states[e]] = {}
            for k in range(self.P.nrows()):
                self.TranProbs['%s' %self.states[e]]['%s' %self.states[k]] = self.P[e][k]

    def Cost(self,state,action):

        if state[-_sage_const_1 ] == _sage_const_0  :

            if action == _sage_const_0 :
                if state[_sage_const_0 ] < self.servers[_sage_const_0 ]:
                    return _sage_const_1 /self.mu[_sage_const_0 ]
                else :
                    return (state[_sage_const_0 ] + _sage_const_1 )/(self.servers[_sage_const_0 ]*self.mu[_sage_const_0 ])

            elif action == _sage_const_1 :
                if state[_sage_const_1 ] < self.servers[_sage_const_1 ]:
                    return _sage_const_1 /self.mu[_sage_const_1 ] + self.beta[_sage_const_0 ]
                else :
                    return (state[_sage_const_1 ] + _sage_const_1 )/(self.servers[_sage_const_1 ]*self.mu[_sage_const_1 ]) + self.beta[_sage_const_0 ]

            elif action == _sage_const_2 :
                return sum(self.beta)

        if state[-_sage_const_1 ] == _sage_const_1  :
            if state[_sage_const_1 ] < self.servers[_sage_const_1 ] and not state[_sage_const_1 ] == _sage_const_0 :
                return _sage_const_1 /self.mu[_sage_const_1 ]
            elif state[_sage_const_1 ] == _sage_const_0 :
                return _sage_const_0 
            else :
                return (state[_sage_const_1 ])/(self.servers[_sage_const_1 ]*self.mu[_sage_const_1 ])

        if state[-_sage_const_1 ] == _sage_const_2 :
            return _sage_const_0 


    def Transition(self,state,T):
        if state[-_sage_const_1 ] == _sage_const_0 :
            objective = []

            for a in self.ADict['%s' %([state[_sage_const_0 ],state[_sage_const_1 ]])]:

                Value = self.Cost(state,a)

                NewState = list(state)
                if not a == _sage_const_2 :
                    NewState[a] += _sage_const_1 
                for e in self.VIAStates:

                    eventtype = _sage_const_0 

                    if e[_sage_const_0 ] == NewState[_sage_const_0 ] - _sage_const_1  and e[_sage_const_1 ] == NewState[_sage_const_1 ] + _sage_const_1 :

                        eventtype = _sage_const_1 

                    elif e[_sage_const_1 ] == NewState[_sage_const_1 ] - _sage_const_1  and e[_sage_const_0 ] == NewState[_sage_const_0 ] :

                        eventtype = _sage_const_2 

                    if eventtype == e[-_sage_const_1 ]:
                        if eventtype == _sage_const_0  :
                            Value += self.TranProbs['%s' %([NewState[_sage_const_0 ],NewState[_sage_const_1 ]])]['%s' %([e[_sage_const_0 ],e[_sage_const_1 ]]) ]*self.StateValues[ T - _sage_const_1  ]['%s' %([max(e[_sage_const_0 ] - _sage_const_1 ,_sage_const_0 )] + e[_sage_const_1 :])]
                        else:
                            Value += self.TranProbs['%s' %([NewState[_sage_const_0 ],NewState[_sage_const_1 ]])]['%s' %([e[_sage_const_0 ],e[_sage_const_1 ]]) ]*self.StateValues[T - _sage_const_1 ]['%s' %([min([e[_sage_const_0 ],self.Selfish[_sage_const_0 ]]),min([e[_sage_const_1 ],self.Selfish[_sage_const_1 ]]),eventtype])]

                objective.append(Value)
            return min(objective),self.ADict['%s' %([state[_sage_const_0 ],state[_sage_const_1 ]])][objective.index(min(objective))]

        else:
            Value = self.Cost(state,_sage_const_0 )

            for e in self.VIAStates:

                eventtype = _sage_const_0 

                if e[_sage_const_0 ] == state[_sage_const_0 ] - _sage_const_1  and e[_sage_const_1 ] == state[_sage_const_1 ] + _sage_const_1 :

                    eventtype = _sage_const_1 

                elif e[_sage_const_1 ] == state[_sage_const_1 ] - _sage_const_1  and e[_sage_const_0 ] == state[_sage_const_0 ] :

                    eventtype = _sage_const_2 


                if eventtype == e[-_sage_const_1 ]:
                    if eventtype == _sage_const_0  :
                        Value += self.TranProbs['%s' %([state[_sage_const_0 ],state[_sage_const_1 ]])]['%s' %([e[_sage_const_0 ],e[_sage_const_1 ]]) ]*self.StateValues[ T - _sage_const_1  ]['%s' %([max(e[_sage_const_0 ] - _sage_const_1 ,_sage_const_0 )] + e[_sage_const_1 :])]

                    else:
                        Value += self.TranProbs['%s' %([state[_sage_const_0 ],state[_sage_const_1 ]])]['%s' %([e[_sage_const_0 ],e[_sage_const_1 ]]) ]*self.StateValues[T - _sage_const_1 ]['%s' %([min([e[_sage_const_0 ],self.Selfish[_sage_const_0 ]]),min([e[_sage_const_1 ],self.Selfish[_sage_const_1 ]]),eventtype])]

            return Value,_sage_const_3 


    def VIA(self,epsilon = _sage_const_0p1 ):

        T = _sage_const_1 
        end = False

        while not end:

            self.StateValues[T] = {}
            self.StateActions[T] = {}

            for s in self.VIAStates:
                Opt = self.Transition(s,T)
                self.StateValues[T]['%s' %(s)] = Opt[_sage_const_0 ]
                self.StateActions[T]['%s' %(s)] = Opt[_sage_const_1 ]

            M = matrix(self.Selfish[_sage_const_0 ]+_sage_const_1 )
            print '---- T = %s ----' %T
            for e in self.VIAStates:

                if e[-_sage_const_1 ] == _sage_const_0  and e[_sage_const_0 ] < _sage_const_20  and e[_sage_const_1 ] < _sage_const_40 :
                    M[e[_sage_const_0 ],e[_sage_const_1 ]] = self.StateActions[T]['%s' %e]
            print M.str()
            RefVal = self.StateValues[T]['%s' %([_sage_const_0 ,_sage_const_0 ,_sage_const_2 ])]

            for e in self.StateValues[T]:
                self.StateValues[T][e] -= RefVal

            epsilonlist = [abs(self.StateValues[T][e] - self.StateValues[T - _sage_const_1 ][e]) for e in self.StateValues[T] ]

            end = True
            print  '%.02f' %self.StateValues[T]['%s'%([_sage_const_0 ,_sage_const_0 ,_sage_const_0 ])]
            print  '%.02f' %max(epsilonlist)
            for e in epsilonlist:
                if e > epsilon:
                    end  = False

            if not end:
                T +=_sage_const_1 

        return self.Plmbda*self.StateValues[T]['%s'%([_sage_const_0 ,_sage_const_0 ,_sage_const_0 ])],self.StateActions[T],M

Simple = Queue(_sage_const_5 ,[_sage_const_3 ,_sage_const_4 ],[_sage_const_2 ,_sage_const_2 ],[_sage_const_0p1 ,_sage_const_0p1 ])
print  '%.02f' %Simple.VIA()[_sage_const_0 ]
