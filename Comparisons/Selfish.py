# This file was *autogenerated* from the file Selfish.sage.
from sage.all_cmdline import *   # import sage library
import N2Expected as N2
import TwoQueueVia3 as VIA
import random
import copy
import csv

class Queue:
    def __init__(self,lmbda,mu,c,skip,expect,bounds = [Integer(20),Integer(20)]):
        self.lmbda  = lmbda
        self.mu = mu
        self.c = c
        self.beta = skip
        self.bounds = bounds
        self.states = []
        self.ExpectDict = expect

        for e in range(self.bounds[Integer(0)]):
            for k in range(sum(self.bounds)):
                   self.states.append([e,k])


    def findselfish(self):
        m = MatrixSpace(QQ,self.bounds[Integer(0)],sum(self.bounds))
        rowdata = []
        for e in self.states:
            print e,self.ExpectDict['%s' %e]
            costs = []
            if e[Integer(0)] < self.c[Integer(0)]:
                if self.ExpectDict['%s' %e] < self.c[Integer(1)]:
                    costs.append(Integer(1)/self.mu[Integer(0)] + Integer(1)/self.mu[Integer(1)] )
                else:
                    costs.append(Integer(1)/self.mu[Integer(0)] + (self.ExpectDict['%s' %e]+Integer(1))/(self.mu[Integer(1)]*self.c[Integer(1)])   )
            else:
                if self.ExpectDict['%s' %e] < self.c[Integer(1)]:
                    costs.append((e[Integer(0)]+Integer(1))/(self.mu[Integer(0)]*self.c[Integer(0)]) + Integer(1)/self.mu[Integer(1)] )
                else:
                    costs.append((e[Integer(0)]+Integer(1))/(self.mu[Integer(0)]*self.c[Integer(0)]) + (self.ExpectDict['%s' %e]+Integer(1))/(self.mu[Integer(1)]*self.c[Integer(1)]) )
            if e[Integer(1)] < self.c[Integer(1)]:
                costs.append(self.beta[Integer(0)] + Integer(1)/self.mu[Integer(1)] )
            else:
                costs.append(self.beta[Integer(0)] + (e[Integer(1)]+Integer(1))/(self.mu[Integer(1)]*self.c[Integer(1)] ))
            costs.append(sum(self.beta))
            print e,costs
            rowdata.append(costs.index(min(costs)))
        m = m(rowdata)
        print m.str()
        return m[Integer(0):self.bounds[Integer(0)] ,Integer(0):self.bounds[Integer(1)]  ]

@parallel
def f(n):
    bark = True
    while bark == True:
        try: 
            mu = [random.uniform(Integer(1),Integer(5)),random.uniform(Integer(1),Integer(5))]
            c = [random.randint(Integer(2),Integer(4)),random.randint(Integer(2),Integer(4))]
            skip = [random.uniform(RealNumber('0.4'),RealNumber('0.5')),random.uniform(RealNumber('0.4'),RealNumber('0.5'))]
            for e in range(Integer(5),Integer(30)):
    
                lmbda = e
    
                A = VIA.Queue(lmbda,mu,c,skip,bounds = [Integer(9),Integer(9)])
                datavia = A.VIA(RealNumber('0.1'))
                new = datavia[Integer(2)]
                Opt = copy.copy(new)
                testpol = None
                count = Integer(0)
                while not new == testpol:
                    print 'woof'
                    testpol = new
                    a = N2.Queue(lmbda,mu,c,testpol,bounds = [Integer(10),Integer(10)])
                    expect = a.findabsorbing()
                    b = Queue(lmbda,mu,c,skip,expect,bounds = [Integer(10),Integer(10)])
                    new = b.findselfish()
                    count += Integer(1)
                    if count >= Integer(10):
                        break
    
                count -=Integer(1)
                #A = VIA.Queue(lmbda,mu,c,skip,Policy = Opt[0:5,0:5])
                #datavia = A.VIA(0.1)
    
                B = VIA.Queue(lmbda,mu,c,skip,Policy = new)
                selfcost = B.VIA(RealNumber('0.1'))[Integer(0)]
                print Opt,new
    
    
                outfile = open('./out/poa/poacurve(%s,%s,%s).csv' %(mu,c,skip),'ab')
                output = csv.writer(outfile)
    
                outrow = []
                outrow.append(e)
    
                outrow.append(mu[Integer(0)])
                outrow.append(mu[Integer(1)])
                outrow.append(c[Integer(0)])
                outrow.append(c[Integer(1)])
                outrow.append(skip[Integer(0)])
                outrow.append(skip[Integer(1)])
    
                outrow.append(datavia[Integer(0)])
                outrow.append(Opt.str())
                outrow.append(selfcost)
                outrow.append(testpol.str())
                outrow.append(count)
    
    
                output.writerow(outrow)
                outfile.close()
                bark = True
        except:
            continue
list(f([Integer(1),Integer(2)]))
#f(7)
