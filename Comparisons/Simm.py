# This file was *autogenerated* from the file Simm.sage.
from sage.all_cmdline import *   # import sage library
_sage_const_3 = Integer(3); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_100 = Integer(100); _sage_const_10000 = Integer(10000); _sage_const_10 = Integer(10); _sage_const_20 = Integer(20)
import random
import csv
import time

global States
States = {}

class Player:
    def __init__(self,Arrival,Dec,arrivestate):
        self.arrival_date = Arrival
        self.Decision = Dec
        self.cost = _sage_const_0 
        self.Queue1end = 'None'
        self.Queue2end = 'None'
        self.arrivalstate = arrivestate
        self.queue2state = 'None'
class Queue:
    def __init__(self,Servers,Rate):
        self.Service_Rate = Rate
        self.Servers = Servers
        self.queue = []
        self.earliest = []
        for e in range(self.Servers):
            self.earliest.append(_sage_const_0 )

class State:
    def __init__(self,i1,i2):
        self.i1 = i1
        self.i2 = i2
        self.times = []
        self.TimeDiff = []
        self.Ti =_sage_const_0 
        self.costs = []
        self.CostDiff = []
        self.Ki = _sage_const_0 
        self.queue2states = []
        self.expectedi2 = i2
def RandExpo(Param):
    return random.expovariate(Param)

def Decision(Policy,Policy_type,state):
    if Policy_type == 'Routing':
        RandValue = random.uniform(_sage_const_0 ,_sage_const_1 )
        for e in range(_sage_const_3 ):
            if RandValue <= sum(Policy[:e+_sage_const_1 ]):
                return e
    else:
        if state[_sage_const_0 ] < Policy.nrows() and state[_sage_const_1 ] < Policy.ncols():

            return Policy[state[_sage_const_0 ],state[_sage_const_1 ]]
        else:
            return _sage_const_2 
def RoutingSimm(lmbda,Rate,Servers,Skip,MaxTime,Policy,Warm_up,i0 = [_sage_const_0 ,_sage_const_0 ],Policy_type = 'Routing'):
    global States
    t = _sage_const_0 
    queues  = {}
    Players = {}
    for e in range(_sage_const_2 ):
        queues[e] = Queue(Servers[e],Rate[e])

    for e in range(i0[_sage_const_0 ]):
        NoPlay = len(Players)
        Players[NoPlay] = Player(t,_sage_const_0 ,[len(queues[_sage_const_0 ].queue),len(queues[_sage_const_1 ].queue)])
        if Players[NoPlay].Decision == _sage_const_1 :
            Players[NoPlay].cost = Skip[_sage_const_0 ]

        Players[NoPlay].ServiceTime = RandExpo(queues[Players[NoPlay].Decision].Service_Rate)
        Players[NoPlay].cost += max(min(queues[Players[NoPlay].Decision].earliest),Players[NoPlay].arrival_date) - Players[NoPlay].arrival_date  + Players[NoPlay].ServiceTime
        queues[Players[NoPlay].Decision].earliest[ queues[Players[NoPlay].Decision].earliest.index( min(queues[Players[NoPlay].Decision].earliest))] = max(min(queues[Players[NoPlay].Decision].earliest),Players[NoPlay].arrival_date) + Players[NoPlay].ServiceTime

        if Players[NoPlay].Decision == _sage_const_0 :
            queues[_sage_const_0 ].queue.append(NoPlay)
            Players[NoPlay].Queue1end = Players[NoPlay].arrival_date + Players[NoPlay].cost
        elif Players[NoPlay].Decision == _sage_const_1 :
            queues[_sage_const_1 ].queue.append(NoPlay)
            Players[NoPlay].Queue2end = Players[NoPlay].arrival_date + Players[NoPlay].cost - Skip[_sage_const_0 ]

    for e in range(i0[_sage_const_1 ]):
        NoPlay = len(Players)
        Players[NoPlay] = Player(t,_sage_const_1 ,[len(queues[_sage_const_0 ].queue),len(queues[_sage_const_1 ].queue)])
        if Players[NoPlay].Decision == _sage_const_1 :
            Players[NoPlay].cost = Skip[_sage_const_0 ]

        Players[NoPlay].ServiceTime = RandExpo(queues[Players[NoPlay].Decision].Service_Rate)
        Players[NoPlay].cost += max(min(queues[Players[NoPlay].Decision].earliest),Players[NoPlay].arrival_date) - Players[NoPlay].arrival_date  + Players[NoPlay].ServiceTime
        queues[Players[NoPlay].Decision].earliest[ queues[Players[NoPlay].Decision].earliest.index( min(queues[Players[NoPlay].Decision].earliest))] = max(min(queues[Players[NoPlay].Decision].earliest),Players[NoPlay].arrival_date) + Players[NoPlay].ServiceTime

        if Players[NoPlay].Decision == _sage_const_0 :
            queues[_sage_const_0 ].queue.append(NoPlay)
            Players[NoPlay].Queue1end = Players[NoPlay].arrival_date + Players[NoPlay].cost
        elif Players[NoPlay].Decision == _sage_const_1 :
            queues[_sage_const_1 ].queue.append(NoPlay)
            Players[NoPlay].Queue2end = Players[NoPlay].arrival_date + Players[NoPlay].cost - Skip[_sage_const_0 ]

    if not '%s,%s' %(len(queues[_sage_const_0 ].queue),len(queues[_sage_const_1 ].queue)) in States:
        States['%s,%s' %(len(queues[_sage_const_0 ].queue),len(queues[_sage_const_1 ].queue))] = State(len(queues[_sage_const_0 ].queue),len(queues[_sage_const_1 ].queue))
    States['%s,%s' %(len(queues[_sage_const_0 ].queue),len(queues[_sage_const_1 ].queue))].times.append(t )
    States['%s,%s' %(len(queues[_sage_const_0 ].queue),len(queues[_sage_const_1 ].queue))].costs.append( sum([Players[e].cost for e in Players]) )

    while t < MaxTime:
        NoPlay = len(Players)
        Players[NoPlay] = Player(t,Decision(Policy,Policy_type,[len(queues[_sage_const_0 ].queue),len(queues[_sage_const_1 ].queue)]),[len(queues[_sage_const_0 ].queue),len(queues[_sage_const_1 ].queue)])
        if Players[NoPlay].Decision == _sage_const_2  :
            Players[NoPlay].cost = sum(Skip)
        else:
            if Players[NoPlay].Decision == _sage_const_1 :
                Players[NoPlay].cost = Skip[_sage_const_0 ]

            Players[NoPlay].ServiceTime = RandExpo(queues[Players[NoPlay].Decision].Service_Rate)
            Players[NoPlay].cost += max(min(queues[Players[NoPlay].Decision].earliest),Players[NoPlay].arrival_date) - Players[NoPlay].arrival_date  + Players[NoPlay].ServiceTime
            queues[Players[NoPlay].Decision].earliest[ queues[Players[NoPlay].Decision].earliest.index( min(queues[Players[NoPlay].Decision].earliest))] = max(min(queues[Players[NoPlay].Decision].earliest),Players[NoPlay].arrival_date) + Players[NoPlay].ServiceTime

            if Players[NoPlay].Decision == _sage_const_0 :
                queues[_sage_const_0 ].queue.append(NoPlay)
                Players[NoPlay].Queue1end = Players[NoPlay].arrival_date + Players[NoPlay].cost
            if Players[NoPlay].Decision == _sage_const_1 :
                queues[_sage_const_1 ].queue.append(NoPlay)
                Players[NoPlay].Queue2end = Players[NoPlay].arrival_date + Players[NoPlay].cost - Skip[_sage_const_0 ]

        if '%s,%s' %(len(queues[_sage_const_0 ].queue),len(queues[_sage_const_1 ].queue)) in States:
            States['%s,%s' %(len(queues[_sage_const_0 ].queue),len(queues[_sage_const_1 ].queue))].times.append(t )
            States['%s,%s' %(len(queues[_sage_const_0 ].queue),len(queues[_sage_const_1 ].queue))].costs.append(sum([Players[e].cost for e in Players]) )
        else:
            States['%s,%s' %(len(queues[_sage_const_0 ].queue),len(queues[_sage_const_1 ].queue))] = State(len(queues[_sage_const_0 ].queue),len(queues[_sage_const_1 ].queue))
            States['%s,%s' %(len(queues[_sage_const_0 ].queue),len(queues[_sage_const_1 ].queue))].times.append(t )
            States['%s,%s' %(len(queues[_sage_const_0 ].queue),len(queues[_sage_const_1 ].queue))].costs.append(sum([Players[e].cost for e in Players]) )

        t += RandExpo(lmbda)

        if not len(queues[_sage_const_0 ].queue + queues[_sage_const_1 ].queue) == _sage_const_0  :
            queue1exit = [Players[e].Queue1end for e in queues[_sage_const_0 ].queue]
            queue2exit = [Players[e].Queue2end for e in queues[_sage_const_1 ].queue]

            while min(queue1exit + queue2exit) < t :

                nextPlayer = (queues[_sage_const_0 ].queue + queues[_sage_const_1 ].queue)[_sage_const_0 ]
                nexttime = Players[nextPlayer].Queue1end
                for e in queues[_sage_const_0 ].queue :
                    if Players[e].Queue1end < nexttime:
                        nextPlayer = e
                        nexttime = Players[nextPlayer].Queue1end
                for e in queues[_sage_const_1 ].queue :
                    if Players[e].Queue2end < nexttime:
                        nextPlayer = e
                        nexttime = Players[nextPlayer].Queue2end

                if nextPlayer in queues[_sage_const_0 ].queue :

                    Players[nextPlayer].ServiceTime2 = RandExpo(queues[_sage_const_1 ].Service_Rate)
                    Players[nextPlayer].cost += max(min(queues[_sage_const_1 ].earliest),Players[nextPlayer].Queue1end) - Players[nextPlayer].Queue1end + Players[nextPlayer].ServiceTime2
                    Players[nextPlayer].Queue2end = max(min(queues[_sage_const_1 ].earliest),Players[nextPlayer].Queue1end) + Players[nextPlayer].ServiceTime2
                    queues[_sage_const_1 ].earliest[ queues[_sage_const_1 ].earliest.index( min(queues[_sage_const_1 ].earliest))] = max(min(queues[_sage_const_1 ].earliest),Players[nextPlayer].Queue1end) + Players[nextPlayer].ServiceTime2
                    Players[nextPlayer].queue2state = len(queues[_sage_const_1 ].queue)
                    queues[_sage_const_0 ].queue.remove(nextPlayer)
                    queues[_sage_const_1 ].queue.append(nextPlayer)

                    if '%s,%s' %(len(queues[_sage_const_0 ].queue),len(queues[_sage_const_1 ].queue)) in States:
                        States['%s,%s' %(len(queues[_sage_const_0 ].queue),len(queues[_sage_const_1 ].queue))].times.append(Players[nextPlayer].Queue1end )
                        States['%s,%s' %(len(queues[_sage_const_0 ].queue),len(queues[_sage_const_1 ].queue))].costs.append(sum([Players[e].cost for e in Players]) )
                    else:
                        States['%s,%s' %(len(queues[_sage_const_0 ].queue),len(queues[_sage_const_1 ].queue))] = State(len(queues[_sage_const_0 ].queue),len(queues[_sage_const_1 ].queue))
                        States['%s,%s' %(len(queues[_sage_const_0 ].queue),len(queues[_sage_const_1 ].queue))].costs.append(sum([Players[e].cost for e in Players]) )
                        States['%s,%s' %(len(queues[_sage_const_0 ].queue),len(queues[_sage_const_1 ].queue))].times.append(Players[nextPlayer].Queue1end )
                else:
                    queues[_sage_const_1 ].queue.remove(nextPlayer)

                    if '%s,%s' %(len(queues[_sage_const_0 ].queue),len(queues[_sage_const_1 ].queue)) in States:
                        States['%s,%s' %(len(queues[_sage_const_0 ].queue),len(queues[_sage_const_1 ].queue))].times.append(Players[nextPlayer].Queue2end )
                        States['%s,%s' %(len(queues[_sage_const_0 ].queue),len(queues[_sage_const_1 ].queue))].costs.append(sum([Players[e].cost for e in Players]) )
                    else:
                        States['%s,%s' %(len(queues[_sage_const_0 ].queue),len(queues[_sage_const_1 ].queue))] = State(len(queues[_sage_const_0 ].queue),len(queues[_sage_const_1 ].queue))
                        States['%s,%s' %(len(queues[_sage_const_0 ].queue),len(queues[_sage_const_1 ].queue))].costs.append(sum([Players[e].cost for e in Players]))
                        States['%s,%s' %(len(queues[_sage_const_0 ].queue),len(queues[_sage_const_1 ].queue))].times.append(Players[nextPlayer].Queue2end )
                if len(queues[_sage_const_0 ].queue + queues[_sage_const_1 ].queue) == _sage_const_0  :
                    break
                else:
                    queue1exit = [Players[e].Queue1end for e in queues[_sage_const_0 ].queue]
                    queue2exit = [Players[e].Queue2end for e in queues[_sage_const_1 ].queue]
    for e in Players:
        if not Players[e].queue2state == 'None' and '%s,%s' %(Players[e].arrivalstate[_sage_const_0 ],Players[e].arrivalstate[_sage_const_0 ]) in States:
            States['%s,%s' %(Players[e].arrivalstate[_sage_const_0 ],Players[e].arrivalstate[_sage_const_1 ])].queue2states.append(Players[e].queue2state)

    #return sum([Players[e].cost for e in Players if Players[e].arrival_date > Warm_up ])/(MaxTime-Warm_up),States
    return sum([Players[e].cost for e in Players if Players[e].arrival_date > Warm_up and Players[e].arrival_date < MaxTime ])/((MaxTime-Warm_up)*(lmbda + sum([Rate[e]*Servers[e] for e in range(_sage_const_2 )]))),States


def Func(lmbda,mu,c,beta,Time,Policy,Plots = False,Data_Points = _sage_const_10000 ,Dataout = True,Run_time = False):
    start = time.time()

    global States
    States = {}
    print 'woof'
    a = RoutingSimm(lmbda,mu,c,beta,Time,Policy,_sage_const_0 )

    maxi1 = _sage_const_0 
    maxi2 = _sage_const_0 
    for e in States:
        if States[e].i1 > maxi1:
            maxi1 = States[e].i1
        if States[e].i2 > maxi2:
            maxi2 = States[e].i2
    maxi1,maxi2 = _sage_const_20 ,_sage_const_20 
    print 'Search space size  = (%s,%s)' %(maxi1,maxi2)

    for i in States['0,0'].times[_sage_const_1 :]:
        for e in States:
            for j in States[e].times:
                if j < i and  j > States['0,0'].times[States['0,0'].times.index(i) - _sage_const_1 ]:
                    States[e].TimeDiff.append(i - j)

    for i in States['0,0'].costs[_sage_const_1 :]:
        for e in States:
            for j in States[e].costs:
                if j < i and  j > States['0,0'].costs[States['0,0'].costs.index(i) - _sage_const_1 ]:
                    States[e].CostDiff.append(i - j)

    for e in range(maxi1 + _sage_const_1 ):
        for k in range(maxi2 + _sage_const_1 ):

            print e,k
            if not '%s,%s' %(e,k) in States:
                States['%s,%s' %(e,k)] = State(e,k)
            while len(States['%s,%s' %(e,k)].TimeDiff) < Data_Points and not [e,k] == [_sage_const_0 ,_sage_const_0 ]:
                print time.time() - start
                if time.time() - start < Run_time:

                    for b in States:
                        States[b].times = []
                        States[b].costs = []
                    a = RoutingSimm(lmbda,mu,c,beta,Time/_sage_const_2 ,Policy,_sage_const_0 ,[e,k])

                    for i in States['0,0'].times:
                        for l in States:
                            for j in States[l].times:
                                if j < States['0,0'].times[_sage_const_0 ]:
                                    States[l].TimeDiff.append(States['0,0'].times[_sage_const_0 ] - j)
                                if j < i and  j > States['0,0'].times[States['0,0'].times.index(i) - _sage_const_1 ]:
                                    States[l].TimeDiff.append(i - j)

                    for i in States['0,0'].costs:
                        for l in States:
                            for j in States[l].costs:
                                if j < States['0,0'].costs[_sage_const_0 ]:
                                    States[l].CostDiff.append(States['0,0'].costs[_sage_const_0 ] - j)
                                if j < i and  j > States['0,0'].costs[States['0,0'].costs.index(i) - _sage_const_1 ] :
                                    States[l].CostDiff.append(i - j)
                else:
                    break

    for l in States:
        if not len(States[l].queue2states) == _sage_const_0 :
            States[l].expectedi2 = sum(States[l].queue2states)/len(States[l].queue2states)
        if not len(States[l].TimeDiff) == _sage_const_0 :
            States[l].Ti = sum(States[l].TimeDiff)/len(States[l].TimeDiff)
        else:
            States[l].Ti = _sage_const_0 
        if not len(States[l].CostDiff) == _sage_const_0 :
            States[l].Ki = sum(States[l].CostDiff)/len(States[l].CostDiff)
        else:
            States[l].Ki = _sage_const_0 

    if False == True:
        outfile = open( './Static/MDP/Comparisons/out/KTValues-(%s,%s,%s,%s,%s,%s).csv' %(lmbda,mu,c,beta,Policy,Data_Points),'wb')
        output = csv.writer(outfile)
        outrow = [lmbda,mu,c,beta,Policy,Data_Points]
        output.writerow(outrow)
        outrow = ['n1','n2','Data Points Used','T','K']
        output.writerow(outrow)
        for e in range(maxi1 + _sage_const_1 ):
            for k in range(maxi2 + _sage_const_1 ):
                outrow = [ e,k,len(States['%s,%s' %(e,k)].CostDiff),States['%s,%s' %(e,k)].Ti,States['%s,%s' %(e,k)].Ki]
                output.writerow(outrow)

        outfile.close()
    if False == True:
        def f(x,y):
            if x == _sage_const_0  and y == _sage_const_0 :
                return _sage_const_0 
            return States['%s,%s' %(int(x),int(y))].Ti
        def g(x,y):
            if x == _sage_const_0  and y == _sage_const_0 :
                return _sage_const_0 
            return States['%s,%s' %(int(x),int(y))].Ki


        for i in range(_sage_const_10 ):
            point1 = random.uniform(_sage_const_1 ,maxi1)
            point2 = random.uniform(_sage_const_1 ,maxi1)

            Total = _sage_const_0 
            count = _sage_const_0 
            plotdata = [[_sage_const_0 ,_sage_const_0 ]]
            for e in States['%s,%s' %(int(point1),int(point2)) ].TimeDiff:

                Total += e
                count += _sage_const_1 
                plotdata.append([count,Total/count])

            R = list_plot(plotdata)
            R.save('./out/AverageCost%s.pdf' %i)

        P = contour_plot(f,(_sage_const_0 ,maxi1),(_sage_const_0 ,maxi2),contours = _sage_const_100 ,colorbar = True)
        P.save('./out/TimeMatrix(%s,%s,%s,%s,%s,%s).pdf' %(lmbda,mu,c,beta,Policy,Data_Points))
        Q = contour_plot(g,(_sage_const_0 ,maxi1),(_sage_const_0 ,maxi2),contours = _sage_const_100 ,colorbar = True)
        Q.save('./out/CostMatrix(%s,%s,%s,%s,%s,%s).pdf' %(lmbda,mu,c,beta,Policy,Data_Points))
    return States,[maxi1,maxi2]
#Func(10,[4,4],[2,4],[2,2],200,[0.25,0.5,0.25],False,10,False)
'''
m = matrix(20)
for e in range(20):
    for i in range(20):

        m[e,i] = 2
zeroes = [[0,0],[0,1],[0,2],[0,3],[1,0],[1,1],[1,2]]
ones = [[0,0],[0,1],[1,0],[2,0],[3,0]]

for i in ones:
    m[i[0],i[1]] = 1
for i in zeroes:
    m[i[0],i[1]] = 0
print m.str()
a = RoutingSimm(49,[5.38,5.74],[3,2],[0.487,0.4605],1000,m,200,[0,0],Policy_type = 'Matrix')
a = RoutingSimm(5,[3,4],[2,2],[0.1,0.1],1000,m,200,[0,0],Policy_type = 'Matrix')
print a[0]
'''
