# This file was *autogenerated* from the file N2Expected.sage.
from sage.all_cmdline import *   # import sage library
_sage_const_2 = Integer(2); _sage_const_20 = Integer(20); _sage_const_0 = Integer(0); _sage_const_1 = Integer(1)

class Queue:
    def __init__(self,lmbda,mu,c,policy,bounds = [_sage_const_20 ,_sage_const_20 ]):
        self.lmbda  = lmbda
        self.mu = mu
        self.c = c
        self.policy = policy
        self.bounds = bounds
        self.states = []
        self.ExpectDict = {}
        self.ProbDict = {}

        for e in range(self.bounds[_sage_const_0 ]):
            for k in range(sum(self.bounds)):
                for j in range(-_sage_const_1 ,max(_sage_const_0 ,e - self.c[_sage_const_0 ] + _sage_const_1  )):
                   self.states.append([e,k,j])

        for e in range(self.bounds[_sage_const_0 ]):
            for k in range(sum(self.bounds)):
               self.states.append([e,k,-_sage_const_2 ])
        self.findQ()
        self.findP()

    def findQ(self):
        Q = MatrixSpace(QQ,len(self.states))
        rowdata = []

        for e in self.states:
            for i in self.states:

                valid = False
                if e[-_sage_const_1 ] > -_sage_const_1 :
                    if i[_sage_const_0 ] == e[_sage_const_0 ] - _sage_const_1  and i[_sage_const_1 ] == e[_sage_const_1 ] + _sage_const_1  and e[_sage_const_2 ] - _sage_const_1  == i[_sage_const_2 ]:
                        rowdata.append(self.c[_sage_const_0 ] * self.mu[_sage_const_0 ])
                        valid = True
                    elif i[_sage_const_0 ] == e[_sage_const_0 ] and i[_sage_const_1 ]  == e[_sage_const_1 ] -_sage_const_1   and e[_sage_const_2 ] == i[_sage_const_2 ]:
                        rowdata.append(min(self.c[_sage_const_1 ],e[_sage_const_1 ]) * self.mu[_sage_const_1 ])
                        valid = True
                    if e[_sage_const_0 ] < self.bounds[_sage_const_0 ] and e[_sage_const_1 ] < self.bounds[_sage_const_1 ]:
                        decision = self.policy[e[_sage_const_0 ],e[_sage_const_1 ]]
                    else:
                        decision = _sage_const_2 

                    if decision == _sage_const_0 :
                        if i[_sage_const_0 ] == e[_sage_const_0 ] + _sage_const_1  and i[_sage_const_1 ] == e[_sage_const_1 ] and e[_sage_const_2 ]  == i[_sage_const_2 ]:
                            rowdata.append(self.lmbda)
                            valid = True

                    elif decision == _sage_const_1 :
                        if i[_sage_const_0 ] == e[_sage_const_0 ]  and i[_sage_const_1 ] == e[_sage_const_1 ] + _sage_const_1  and e[_sage_const_2 ]  == i[_sage_const_2 ]:
                            rowdata.append(self.lmbda)
                            valid = True

                    if not valid:
                        rowdata.append(_sage_const_0 )

                elif e[-_sage_const_1 ] == -_sage_const_1 :
                    if i[_sage_const_0 ] == e[_sage_const_0 ] - _sage_const_1  and i[_sage_const_1 ] == e[_sage_const_1 ] + _sage_const_1  and e[_sage_const_2 ] - _sage_const_1  == i[_sage_const_2 ]:
                        rowdata.append(self.mu[_sage_const_0 ])
                        valid = True
                    elif i[_sage_const_0 ] == e[_sage_const_0 ] - _sage_const_1  and i[_sage_const_1 ] == e[_sage_const_1 ] + _sage_const_1  and e[_sage_const_2 ] == i[_sage_const_2 ]:
                        rowdata.append(self.mu[_sage_const_0 ] *(min(self.c[_sage_const_0 ],e[_sage_const_0 ]) - _sage_const_1  ))
                        valid = True
                    elif i[_sage_const_0 ] == e[_sage_const_0 ] and i[_sage_const_1 ]  == e[_sage_const_1 ] - _sage_const_1   and e[_sage_const_2 ] == i[_sage_const_2 ]:
                        rowdata.append(min(self.c[_sage_const_1 ],e[_sage_const_1 ]) * self.mu[_sage_const_1 ])
                        valid = True

                    if e[_sage_const_0 ] < self.bounds[_sage_const_0 ] and e[_sage_const_1 ] < self.bounds[_sage_const_1 ]:
                        decision = self.policy[e[_sage_const_0 ],e[_sage_const_1 ]]
                    else:
                        decision = _sage_const_2 

                    if decision == _sage_const_0 :
                        if i[_sage_const_0 ] == e[_sage_const_0 ] + _sage_const_1  and i[_sage_const_1 ] == e[_sage_const_1 ] and e[_sage_const_2 ]  == i[_sage_const_2 ]:
                            rowdata.append(self.lmbda)
                            valid = True

                    elif decision == _sage_const_1 :
                        if i[_sage_const_0 ] == e[_sage_const_0 ]  and i[_sage_const_1 ] == e[_sage_const_1 ] + _sage_const_1  and e[_sage_const_2 ]  == i[_sage_const_2 ]:
                            rowdata.append(self.lmbda)
                            valid = True

                    if not valid:
                        rowdata.append(_sage_const_0 )

                elif e[-_sage_const_1 ] == -_sage_const_2 :
                    rowdata.append(_sage_const_0 )

        self.Q = Q(rowdata)
        rowsums = [sum(e) for e in self.Q]
        for i in range(len(rowsums)):
            self.Q[i,i] = -rowsums[i]

    def findP(self):
        Diag = []
        for i in range(len(self.states)):
            Diag.append(abs(self.Q[i,i]))
        t = _sage_const_1 /max(Diag)
        self.P = self.Q*t + identity_matrix(len(self.states))


    def findabsorbing(self):
        states = _sage_const_0 
        while not self.states[states][-_sage_const_1 ] == -_sage_const_2 :
            states += _sage_const_1 

        T = MatrixSpace(QQ,states)
        B = MatrixSpace(QQ,states,len(self.states) - states)
        rowdata = []
        for e in range(states):
            for i in range(states):

                rowdata.append(self.P[e,i])
        T = T(rowdata)
        rowdata = []
        for e in range(states):
            for i in range(states,len(self.states)):
               rowdata.append(self.P[e,i])
        B = B(rowdata)
        A = ((identity_matrix(states) - T).inverse())*B

        for e in range(states):
            if self.states[e][-_sage_const_1 ] == max(-_sage_const_1 ,self.states[e][_sage_const_0 ] - self.c[_sage_const_0 ]) :
                self.ExpectDict['%s' %self.states[e][_sage_const_0 :_sage_const_2 ]] = {}
                for i in range(len(self.states) - states):
                    if '%s' %self.states[i + states][_sage_const_1 ] in self.ExpectDict['%s' %self.states[e][_sage_const_0 :_sage_const_2 ]]:
                        self.ExpectDict['%s' %self.states[e][_sage_const_0 :_sage_const_2 ]]['%s' %self.states[i + states][_sage_const_1 ]] += A[e,i]
                    else:
                        self.ExpectDict['%s' %self.states[e][_sage_const_0 :_sage_const_2 ]]['%s' %self.states[i + states][_sage_const_1 ]] = A[e,i]
                self.ProbDict['%s' %self.states[e][_sage_const_0 :_sage_const_2 ]] = sum([eval(i)*self.ExpectDict['%s' %self.states[e][_sage_const_0 :_sage_const_2 ]][i] for i in self.ExpectDict['%s' %self.states[e][_sage_const_0 :_sage_const_2 ]] ])
        return self.ProbDict

